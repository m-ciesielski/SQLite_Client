package sqliteDB;

import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.Date;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Time;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.logging.Logger;

import javax.swing.JOptionPane;
import javax.swing.table.AbstractTableModel;

import sqliteDB.Query.MainStatement;

/**
 * Class Query creates SQL Insert, Update and Delete statements as strings ready
 * to execute by Statement.execute() method.
 * 
 * @author Owen TODO: constructors unification, refactor
 */

abstract class AbstractModel {
	static Statement stat;
	static Connection conn;
}

/**
 * TableModel interface prototype. TableModel is responsible for fetching table
 * data from database.
 * 
 * @author Owen
 *
 */
interface TableModel {
	String getTableName();

	void setTableName(String name);

	Collection<? extends Object> getTableData();

	/**
	 * @return Collection of names of primary key columns.
	 */
	Collection<String> getPrimaryKeyColumns();

	int getPrimaryKeyColumnsCount();

	List<String> getColumnNames();

	/**
	 * @return Collection of names of columns classes.
	 */
	Collection<String> getColumnClasses();

	void executeQuery(String query) throws SQLException;
}

// TODO: create method for fetching string only data for combo boxes usage
class DefaultTableModel extends AbstractModel implements Loggable, TableModel {
	private String tableName;
	private ArrayList<String> primaryKeyColumns = new ArrayList<String>();
	private ArrayList<String> foreignKeyColumns = new ArrayList<String>();
	private ArrayList<String> referencedTables = new ArrayList<String>();

	public DefaultTableModel(String tableName) {
		this.tableName = tableName;
		fetchPrimaryKeyColumns();
		fetchForeignKeyColumns();
		fetchReferencedTables();
	}

	public DefaultTableModel() {

	}

	public String getTableName() {
		return this.tableName;
	};

	// TODO:refactor
	public void setTableName(String tableName) {
		this.tableName = tableName;
		fetchPrimaryKeyColumns();
		fetchForeignKeyColumns();
		fetchReferencedTables();
	}

	public ArrayList<String> getPrimaryKeyColumns() {
		return primaryKeyColumns;
	}

	public ArrayList<String> getReferencedTablesNames() {
		return referencedTables;
	}

	public ArrayList<DefaultTableModel> getReferencedTables() {
		ArrayList<DefaultTableModel> refTables= new ArrayList<DefaultTableModel>();
		for(int i=0;i<referencedTables.size();++i)
			refTables.add(new DefaultTableModel(referencedTables.get(i)));
		
		return refTables;
	}

	public int getPrimaryKeyColumnsCount() {
		return primaryKeyColumns.size();
	}

	public ArrayList<String> getColumnNames() {
		ResultSet result;
		ArrayList<String> list = new ArrayList<String>();
		try {
			result = stat.executeQuery("SELECT * FROM " + tableName);
			ResultSetMetaData meta = result.getMetaData();
			result.next();

			for (int i = 1; i <= meta.getColumnCount(); ++i) {
				list.add(meta.getColumnLabel(i));
			}
			result.close();
		} catch (SQLException e) {
			LOGGER.warning("SQL Error encountered when fetching " + tableName
					+ " column names.");
			e.printStackTrace();
		}

		return list;
	}

	public ArrayList<String> getColumnClasses() {
		ResultSet result;
		ArrayList<String> list = new ArrayList<String>();
		try {
			result = stat.executeQuery("SELECT * FROM " + tableName);
			ResultSetMetaData meta = result.getMetaData();
			result.next();

			System.out.print(" ");
			for (int i = 1; i <= meta.getColumnCount(); ++i) {
				list.add(meta.getColumnTypeName(i));
			}
			result.close();
		} catch (SQLException e) {
			LOGGER.warning("SQL Error encountered when fetching " + tableName
					+ " column classes.");
			e.printStackTrace();
		}

		return list;

	}

	/**
	 * This method retrieves data of table defined by tableName field of
	 * DefaultTableModel
	 * 
	 * @return table data as ArrayList of ArrayLists of Objects
	 */
	public ArrayList<ArrayList<Object>> getTableData() {
		ResultSet result;
		ArrayList<ArrayList<Object>> data = new ArrayList<ArrayList<Object>>();
		ArrayList<Object> temp = new ArrayList<Object>();

		try {
			result = stat.executeQuery("SELECT * FROM " + tableName);
			ResultSetMetaData meta = result.getMetaData();
			result.next();
			while (result.isAfterLast() == false) {
				for (int i = 1; i <= meta.getColumnCount(); ++i)
					temp.add(result.getObject(i));

				data.add(temp);
				temp = new ArrayList<Object>();

				result.next();
			}
			result.close();
		} catch (SQLException e) {
			LOGGER.warning("SQL Error encountered when fetching " + tableName
					+ " data.");
			e.printStackTrace();
		}

		return data;
	}

	/**
	 * This method executes statement generated by Query class. SQLException is
	 * thrown up stack to enable error handling in callers of this method.
	 */
	public void executeQuery(String query) throws SQLException {
		try {
			stat.execute(query);
			LOGGER.info("Query Executed: " + query);
		} catch (SQLException e) {
			LOGGER.info("Query: " + query + " cannot be executed.");
			throw e;
		}
	}

	private void fetchReferencedTables() {
		ResultSet result;
		foreignKeyColumns.clear();
		try {
			DatabaseMetaData meta = conn.getMetaData();
			result = meta.getImportedKeys(null, null, tableName);
			result.next();
			while (result.isAfterLast() == false) {
				referencedTables.add(result.getString(7));
				result.next();
			}
		} catch (SQLException e) {
			LOGGER.warning("SQL Error encountered when fetching Referenced Tables Names of "
					+ tableName);
			e.printStackTrace();
		}

	}

	/**
	 * This method retrieves foreign key columns from database meta data and
	 * stores their names in foreignKeyColumns field.
	 */
	private void fetchForeignKeyColumns() {
		ResultSet result;
		foreignKeyColumns.clear();
		try {
			DatabaseMetaData meta = conn.getMetaData();
			result = meta.getImportedKeys(null, null, tableName);
			result.next();
			while (result.isAfterLast() == false) {
				foreignKeyColumns.add(result.getString(8));
				result.next();
			}
		} catch (SQLException e) {
			LOGGER.warning("SQL Error encountered when fetching Foreign Keys of "
					+ tableName);
			e.printStackTrace();
		}

	}

	/**
	 * This method retrieves primary key columns from database meta data and
	 * stores their names in primaryKeyColumns field. JDBC GetPrimaryKeys
	 * function seems to return primary key column names WITHOUT capital
	 * letters, so comparison with any column name usually requires proper
	 * conversion.
	 */
	private void fetchPrimaryKeyColumns() {
		ResultSet result;
		primaryKeyColumns.clear();
		try {
			DatabaseMetaData meta = conn.getMetaData();
			result = meta.getPrimaryKeys(null, null, tableName);
			result.next();
			while (result.isAfterLast() == false) {
				primaryKeyColumns.add(result.getString(4));
				result.next();
			}
		} catch (SQLException e) {
			LOGGER.warning("SQL Error encountered when fetching Primary Keys of "
					+ tableName);
			e.printStackTrace();
		}

		return;
	}

}

/**
 * Class SidePanelModel is responsible for fetching and storing information
 * about tables and views in database
 * 
 * @author Owen
 *
 */
class SidePanelModel extends AbstractModel implements Loggable {
	private ArrayList<String> tableNames;
	private ArrayList<String> viewNames;

	public SidePanelModel() {
		tableNames = new ArrayList<String>();
		viewNames = new ArrayList<String>();
	}

	public void fetchTableNames() {
		try {
			ResultSet result = stat
					.executeQuery("SELECT COUNT(*) FROM sqlite_master WHERE type='table';");
			result.next();
			int tableCount = (result.getInt(1));
			result = stat
					.executeQuery("SELECT * FROM sqlite_master WHERE type='table';");
			for (int i = 0; i < tableCount; ++i) {
				result.next();
				tableNames.add(result.getString("name"));
			}
			result.close();
		} catch (SQLException e) {
			LOGGER.warning("SQL Error encountered when fetching table names.");
			e.printStackTrace();
		}

	}

	public void fetchViewNames() {
		try {
			ResultSet result = stat
					.executeQuery("SELECT COUNT(*) FROM sqlite_master WHERE type='view';");
			result.next();
			int tableCount = (result.getInt(1));
			result = stat
					.executeQuery("SELECT * FROM sqlite_master WHERE type='view';");
			for (int i = 0; i < tableCount; ++i) {
				result.next();
				viewNames.add(result.getString("name"));
			}
			result.close();
		} catch (SQLException e) {
			LOGGER.warning("SQL Error encountered when fetching view names.");
			e.printStackTrace();
		}

	}

	public void clearTableNames() {
		tableNames.clear();
	}

	public void clearViewNames() {
		viewNames.clear();
	}

	public boolean tableNamesCleared() {
		return tableNames.isEmpty();
	}

	public ArrayList<String> getTableNames() {
		return tableNames;
	}

	public String getTableName(int index) {
		return tableNames.get(index);
	}

	public ArrayList<String> getViewNames() {
		return viewNames;
	}

	public String getViewName(int index) {
		return viewNames.get(index);
	}
}

/**
 * Class TableEditionModel is customized AbstracTableModel class of JTable view
 * (table in TablePanel class) linked DatabaseTableModel allows performing
 * Update statements on table by overridden setValueAt method
 * 
 * @author Owen
 *
 */
class TableEditionModel extends AbstractTableModel {
	private String[] columnNames;
	private Object[][] data;
	private DefaultTableModel dbTableModel;

	public TableEditionModel(Object[][] data, String[] columnNames,
			DefaultTableModel dbTableModel) {
		this.data = data;
		this.columnNames = columnNames;
		this.dbTableModel = dbTableModel;
	}

	@Override
	public int getColumnCount() {
		return columnNames.length;
	}

	@Override
	public int getRowCount() {
		return data.length;
	}

	@Override
	public Object getValueAt(int row, int col) {
		return data[row][col];
	}

	public String getColumnName(int col) {
		return columnNames[col];
	}

	public boolean isCellEditable(int row, int col) {
		return true;
	}

	public Class getColumnClass(int column) {
		try {
			getValueAt(0, column).getClass();
		} catch (NullPointerException e) {
			return String.class;
		} catch (ArrayIndexOutOfBoundsException e) {
			return String.class;
		}
		return getValueAt(0, column).getClass();
	}

	private int[] getPrimaryKeysValues(int row) {
		ArrayList<String> primaryColumns = dbTableModel.getPrimaryKeyColumns();

		int[] pKeys = new int[primaryColumns.size()];
		int k=0;
		
		for (int i = 0; i < data[0].length; ++i)
			for (int j = 0; j < primaryColumns.size(); ++j) {
				// Lower case conversion needed
				if (getColumnName(i).toLowerCase()
						.equals(primaryColumns.get(j)))
				{
					pKeys[k] = (int) getValueAt(row, i);
					++k;
				}
					
			}

		return pKeys;

	}

	/**
	 * This method is called whenever any field of table is updated. It creates
	 * and executes appropriate update statement.
	 * 
	 */
	public void setValueAt(Object value, int row, int col) {
		if (value.equals(data[row][col]) == false) {

			Query query = new Query(Query.MainStatement.UPDATE,
					dbTableModel.getTableName(),
					dbTableModel.getPrimaryKeyColumns(),
					getPrimaryKeysValues(row), value, getColumnName(col));
			try {
				dbTableModel.executeQuery(query.createQueryString());
			} catch (SQLException e) {
				JOptionPane.showMessageDialog(null,
						"Nowa wartoœæ jest niepoprawna.");
				return;
			}

			data[row][col] = value;
			fireTableCellUpdated(row, col);
		}

	}

	/**
	 * Gets next available ID value for given column.
	 * 
	 * @param col
	 *            index of primary key column
	 * @return 1+max primary key value of column at given index
	 */
	public int getNextID(int col) {
		if (col > data[0].length)
			throw new IllegalArgumentException("Column id is out of range.");
		int nextID = 0;
		for (int i = 0; i < data[0].length; ++i) {
			if ((int) data[i][col] > nextID)
				nextID = (int) data[col][i];
		}

		return nextID;
	}
}